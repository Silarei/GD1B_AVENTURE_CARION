<!doctype html>
<html lang="en">
    <head>
        <meta charset="UTF-8" /><title>Aventure</title>
        <script src="//cdn.jsdelivr.net/npm/phaser@3.55.2/dist/phaser.js"></script>
        <style type="text/css"> body { margin: 0; }</style>
    </head>

    <body>
        <script type="text/javascript">

            /*J'en profite pour m'excuser de la lisibilité du code, il en est encore qu'au début et il est déjà dégueulasse. Désolé.*/

            //https://phaser.io/examples/v3/view/tilemap/collision/matter-platformer-with-wall-jumping

            

            class Scene1 extends Phaser.Scene {
                constructor(){
                    super({key : "Scene1" });
                }

                preload () {
                    this.load.image('ship', 'assets/sprites/star.png');
                    this.load.image('bullet1', 'assets/sprites/bomb.png');
                    this.load.image('sky', 'assets/sky.png');
                    this.load.tilemapTiledJSON('map', 'assets/matter-platformer.json');
                    this.load.image('kenney_redux_64x64', 'assets/kenney_redux_64x64.png');
                }

                create () {
                    this.cursors = this.input.keyboard.createCursorKeys();
                    this.speed = Phaser.Math.GetSpeed(300, 1);
                    this.lastFired = 0;
                    this.isDown = false;
                    this.mouseX=0;
                    this.mouseY=0;
                    this.add.image(400, 300, 'sky');
                    this.spaceKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.SPACE);
                    this.playerController;
                    this.text;
                    this.cam;
                    this.smoothedControls;
                    
                    var Bullet = new Phaser.Class({

                        Extends: Phaser.GameObjects.Image,
                        initialize:

                        function Bullet (scene) {
                            Phaser.GameObjects.Image.call(this, scene, 0, 0, 'bullet1');

                            this.incX = 0;
                            this.incY = 0;
                            this.lifespan = 0;

                            this.speed = Phaser.Math.GetSpeed(600, 1);
                        },

                        fire: function (ship, x, y) {
                            this.setActive(true);
                            this.setVisible(true);
                            this.setPosition(ship.x, ship.y);

                            var angle = Phaser.Math.Angle.Between(x, y, ship.x, ship.y);

                            this.setRotation(angle);

                            this.incX = Math.cos(angle);
                            this.incY = Math.sin(angle);

                            this.lifespan = 1000;
                        },

                        update: function (time, delta) {
                            this.lifespan -= delta;

                            this.x -= this.incX * (this.speed * delta);
                            this.y -= this.incY * (this.speed * delta);

                            if (this.lifespan <= 0) {
                                this.setActive(false);
                                this.setVisible(false);
                            }
                        }

                    });

                    var SmoothedHorizontalControl = new Phaser.Class({
                    initialize:

                    function SmoothedHorizontalControl (speed)
                    {
                        this.msSpeed = speed;
                        this.value = 0;
                    },

                    moveLeft: function (delta)
                    {
                        if (this.value > 0) { this.reset(); }
                        this.value -= this.msSpeed * delta;
                        if (this.value < -1) { this.value = -1; }
                    },

                    moveUp: function (delta)
                    {
                        if (this.value < 0) { this.reset(); }
                        this.value -= this.msSpeed * delta;
                        if (this.value > 1) { this.value = 1;}
                    },

                    moveRight: function (delta)
                    {
                        if (this.value < 0) { this.reset(); }
                        this.value += this.msSpeed * delta;
                        if (this.value > 1) { this.value = 1; }
                    },

                    moveDown: function (delta)
                    {
                        if (this.value > 0) { this.reset(); }
                        this.value += this.msSpeed * delta;
                        if (this.value < -1) { this.value = -1; }
                    },

                    reset: function ()
                    {
                        this.value = 0;
                    }
                });

                    this.bullets = this.add.group({
                        classType: Bullet,
                        maxSize: 50,
                        runChildUpdate: true
                    });
                    
                    this.map = this.make.tilemap({ key: 'map' });
                    this.tileset = this.map.addTilesetImage('kenney_redux_64x64');
                    this.layer = this.map.createLayer(0, this.tileset, 0, 0);

                    // Set up the layer to have matter bodies. Any colliding tiles will be given a Matter body.
                    this.map.setCollisionByProperty({ collides: true });
                    this.matter.world.convertTilemapLayer(this.layer);

                    this.matter.world.setBounds(this.map.widthInPixels, this.map.heightInPixels);
                    this.matter.world.createDebugGraphic();
                    this.matter.world.drawDebug = false;

                    this.smoothedControls = new SmoothedHorizontalControl(0.0005);

                    // The player is a collection of bodies and sensors
                    this.playerController = {
                        matterSprite: this.matter.add.sprite(0, 0, 'ship', 0),
                        blocked: {
                            left: false,
                            right: false,
                            bottom: false,
                            up: false
                        },
                        numTouching: {
                            left: 0,
                            right: 0,
                            bottom: 0,
                            up: 0
                        },
                        sensors: {
                            bottom: null,
                            left: null,
                            right: null,
                            up: null
                        },
                        time: {
                            leftDown: 0,
                            rightDown: 0
                        },
                        lastJumpedAt: 0,
                        speed: {
                            run: 5
                        }
                    };

                    this.M = Phaser.Physics.Matter.Matter;
                    this.w = this.playerController.matterSprite.width;
                    this.h = this.playerController.matterSprite.height;

                    // The player's body is going to be a compound body:
                    //  - playerBody is the solid body that will physically interact with the world. It has a
                    //    chamfer (rounded edges) to avoid the problem of ghost vertices: http://www.iforce2d.net/b2dtut/ghost-vertices
                    //  - Left/right/bottom sensors that will not interact physically but will allow us to check if
                    //    the player is standing on solid ground or pushed up against a solid object.

                    // Move the sensor to player center
                    this.sx = this.w / 2;
                    this.sy = this.h / 2;

                    // The player's body is going to be a compound body.
                    this.playerBody = this.M.Bodies.rectangle(this.sx, this.sy, this.w * 0.75, this.h, { chamfer: { radius: 10 } });
                    this.playerController.sensors.bottom = this.M.Bodies.rectangle(this.sx, this.h, this.sx, 5, { isSensor: true });
                    this.playerController.sensors.left = this.M.Bodies.rectangle(this.sx - this.w * 0.45, this.sy, 5, this.h * 0.25, { isSensor: true });
                    this.playerController.sensors.right = this.M.Bodies.rectangle(this.sx + this.w * 0.45, this.sy, 5, this.h * 0.25, { isSensor: true });
                    this.compoundBody = this.M.Body.create({
                        parts: [
                            this.playerBody, this.playerController.sensors.bottom, this.playerController.sensors.left,
                            this.playerController.sensors.right
                        ],
                        friction: 0.01,
                        restitution: 0.05 // Prevent body from sticking against a wall
                    });

                    this.playerController.matterSprite
                        .setExistingBody(this.compoundBody)
                        .setFixedRotation() // Sets max inertia to prevent rotation
                        .setPosition(630, 1000);

                    this.cam = this.cameras.main;
                    this.cam.setBounds(0, 0, this.map.widthInPixels, this.map.heightInPixels);
                    smoothMoveCameraTowards(this.playerController.matterSprite, this.cam);

                    // Use matter events to detect whether the player is touching a surface to the left, right or
                    // bottom.

                    // Before matter's update, reset the player's count of what surfaces it is touching.
                    this.matter.world.on('beforeupdate', (function (event) {
                        this.playerController.numTouching.left = 0;
                        this.playerController.numTouching.right = 0;
                        this.playerController.numTouching.bottom = 0;
                    }).bind(this));

                    // Loop over the active colliding pairs and count the surfaces the player is touching.
                    this.matter.world.on('collisionactive', (function (event)
                    {
                        this.playerBody = this.playerController.body;
                        this.left = this.playerController.sensors.left;
                        this.right = this.playerController.sensors.right;
                        this.bottom = this.playerController.sensors.bottom;

                        for (this.i = 0; this.i < event.pairs.length; this.i++)
                        {
                            this.bodyA = event.pairs[this.i].bodyA;
                            this.bodyB = event.pairs[this.i].bodyB;

                            if (this.bodyA === this.playerBody || this.bodyB === this.playerBody)
                            {
                                continue;
                            }
                            else if (this.bodyA === this.bottom || this.bodyB === this.bottom)
                            {
                                // Standing on any surface counts (e.g. jumping off of a non-static crate).
                                this.playerController.numTouching.bottom += 1;
                            }
                            else if ((this.bodyA === this.left && this.bodyB.isStatic) || (this.bodyB === this.left && this.bodyA.isStatic))
                            {
                                // Only static objects count since we don't want to be blocked by an object that we
                                // can push around.
                                this.playerController.numTouching.left += 1;
                            }
                            else if ((this.bodyA === this.right && this.bodyB.isStatic) || (this.bodyB === this.right && this.bodyA.isStatic))
                            {
                                this.playerController.numTouching.right += 1;
                            }
                        }
                    }).bind(this));

                    // Update over, so now we can determine if any direction is blocked
                    this.matter.world.on('afterupdate', (function (event) {
                        this.playerController.blocked.right = this.playerController.numTouching.right > 0 ? true : false;
                        this.playerController.blocked.left = this.playerController.numTouching.left > 0 ? true : false;
                        this.playerController.blocked.bottom = this.playerController.numTouching.bottom > 0 ? true : false;
                        this.playerController.blocked.up = this.playerController.numTouching.up > 0 ? true : false;
                    }).bind(this));

                    this.input.on('pointerdown', function () {
                        this.matter.world.drawDebug = !this.matter.world.drawDebug;
                        this.matter.world.debugGraphic.visible = this.matter.world.drawDebug;
                    }, this);

                    this.text = this.add.text(16, 16, '', {
                        fontSize: '20px',
                        padding: { x: 20, y: 10 },
                        backgroundColor: '#ffffff',
                        fill: '#000000'
                    });
                    this.text.setScrollFactor(0);
                    updateText(this.text);

                    this.input.on('pointerdown', pointer =>  {

                        this.isDown = true;
                        this.mouseX = pointer.x;
                        this.mouseY = pointer.y;

                    });

                    this.input.on('pointermove', pointer =>  {

                        this.mouseX = pointer.x;
                        this.mouseY = pointer.y;

                    });

                    this.input.on('pointerup', pointer =>  {

                        this.isDown = false;

                    });
                }

                update (time, delta) {

                    if (this.isDown && time > this.lastFired) {
                        this.bullet = this.bullets.get();

                        if (this.bullet) {
                            this.bullet.fire(this.playerController.matterSprite, this.mouseX, this.mouseY);

                            this.lastFired = time + 500;
                        }
                    }
                    this.matterSprite = this.playerController.matterSprite;

                    this.matterSprite.setRotation(Phaser.Math.Angle.Between(this.mouseX, this.mouseY, this.matterSprite.x, this.matterSprite.y) - Math.PI / 2);

                    // Movement

                    this.oldVelocityX;
                    this.targetVelocityX;
                    this.newVelocityX;
                    this.oldVelocityY;
                    this.targetVelocityY;
                    this.newVelocityY;

                    if (this.cursors.left.isDown && !this.playerController.blocked.left)
                    {
                        this.smoothedControls.moveLeft(delta);

                        // Lerp the velocity towards the max run using the smoothed controls. This simulates a
                        // player controlled acceleration.
                        this.oldVelocityX = this.matterSprite.body.velocity.x;
                        this.targetVelocityX = -this.playerController.speed.run;
                        this.newVelocityX = Phaser.Math.Linear(this.oldVelocityX, this.targetVelocityX, -this.smoothedControls.value);

                        this.matterSprite.setVelocityX(this.newVelocityX);
                    }
                    else if (this.cursors.right.isDown && !this.playerController.blocked.right)
                    {
                        this.smoothedControls.moveRight(delta);

                        // Lerp the velocity towards the max run using the smoothed controls. This simulates a
                        // player controlled acceleration.
                        this.oldVelocityX = this.matterSprite.body.velocity.x;
                        this.targetVelocityX = this.playerController.speed.run;
                        this.newVelocityX = Phaser.Math.Linear(this.oldVelocityX, this.targetVelocityX, this.smoothedControls.value);

                        this.matterSprite.setVelocityX(this.newVelocityX);
                    }
                    else if (this.cursors.up.isDown && !this.playerController.blocked.up)
                    {
                        this.smoothedControls.moveUp(delta);

                        // Lerp the velocity towards the max run using the smoothed controls. This simulates a
                        // player controlled acceleration.
                        this.oldVelocityY = this.matterSprite.body.velocity.y;
                        this.targetVelocityY = this.playerController.speed.run;
                        this.newVelocityY = Phaser.Math.Linear(this.oldVelocityY, this.targetVelocityY, this.smoothedControls.value);

                        this.matterSprite.setVelocityY(this.newVelocityY);
                    }
                    else if (this.cursors.down.isDown && !this.playerController.blocked.bottom)
                    {
                        this.smoothedControls.moveDown(delta);

                        // Lerp the velocity towards the max run using the smoothed controls. This simulates a
                        // player controlled acceleration.
                        this.oldVelocityY = this.matterSprite.body.velocity.y;
                        this.targetVelocityY = -this.playerController.speed.run;
                        this.newVelocityY = Phaser.Math.Linear(this.oldVelocityY, this.targetVelocityY, -this.smoothedControls.value);

                        this.matterSprite.setVelocityY(this.newVelocityY);
                    }
                    else
                    {
                        this.smoothedControls.reset();
                    }

                    smoothMoveCameraTowards(this.matterSprite, this.cam, 0.9);
                    updateText(this.text);
                }
            }









































            class MyScene extends Phaser.Scene {
                constructor(){
                    super({key : "MyScene" });
                }
                
                preload(){
                    this.load.image('sky', 'assets/sky.png');
                    this.load.image('ground', 'assets/platform.png');
                    this.load.image('star', 'assets/star.png');
                    this.load.image('bomb', 'assets/bomb.png');
                    this.load.spritesheet('dude', 'assets/dude.png', { frameWidth: 32, frameHeight: 48 });
                }
                create(){
                    this.gameOver = false;
                    //  A simple background for our game
                    this.add.image(400, 300, 'sky');

                    //  The platforms group contains the ground and the 2 ledges we can jump on
                    this.platforms = this.physics.add.staticGroup();

                    //  Here we create the ground.
                    //  Scale it to fit the width of the game (the original sprite is 400x32 in size)
                    this.platforms.create(400, 568, 'ground').setScale(2).refreshBody();

                    //  Now let's create some ledges
                    this.platforms.create(600, 400, 'ground');
                    this.platforms.create(50, 250, 'ground');
                    this.platforms.create(750, 220, 'ground');

                    // The player and its settings
                    this.ship = this.physics.add.sprite(100, 450, 'dude');

                    //  Player physics properties. Give the little guy a slight bounce.
                    this.ship.setBounce(0.2);
                    this.ship.setCollideWorldBounds(true);

                    //  Our player animations, turning, walking left and walking right.
                    this.anims.create({
                        key: 'left',
                        frames: this.anims.generateFrameNumbers('dude', { start: 0, end: 3 }),
                        frameRate: 10,
                        repeat: -1
                    });

                    this.anims.create({
                        key: 'turn',
                        frames: [ { key: 'dude', frame: 4 } ],
                        frameRate: 20
                    });

                    this.anims.create({
                        key: 'right',
                        frames: this.anims.generateFrameNumbers('dude', { start: 5, end: 8 }),
                        frameRate: 10,
                        repeat: -1
                    });

                    //  Input Events
                    this.cursors = this.input.keyboard.createCursorKeys();

                    //  Some stars to collect, 12 in total, evenly spaced 70 pixels apart along the x axis
                    this.stars = this.physics.add.group({
                        key: 'star',
                        repeat: 11,
                        setXY: { x: 12, y: 0, stepX: 70 }
                    });

                    this.stars.children.iterate(function (child) {

                        //  Give each star a slightly different bounce
                        child.setBounceY(Phaser.Math.FloatBetween(0.4, 0.8));

                    });

                    this.bombs = this.physics.add.group();

                    //  The score
                    this.scoreText = this.add.text(16, 16, 'score: 0', { fontSize: '32px', fill: '#000' });

                    //  Collide the player and the stars with the platforms
                    this.physics.add.collider(this.player, this.platforms);
                    this.physics.add.collider(this.stars, this.platforms);
                    this.physics.add.collider(this.bombs, this.platforms);

                    //  Checks to see if the player overlaps with any of the stars, if he does call the collectStar function
                    this.physics.add.overlap(this.player, this.stars, this.collectStar, null, this);

                    this.physics.add.collider(this.player, this.bombs, hitBomb, null, this);
                }
                
                update(){
                    if (this.gameOver)
                    {
                        return;
                    }

                    if (this.cursors.left.isDown)
                    {
                        this.player.setVelocityX(-160);

                        this.player.anims.play('left', true);
                    }
                    else if (this.cursors.right.isDown)
                    {
                        this.player.setVelocityX(160);

                        this.player.anims.play('right', true);
                    }
                    else
                    {
                        this.player.setVelocityX(0);

                        this.player.anims.play('turn');
                    }

                    if (this.cursors.up.isDown && this.player.body.touching.down)
                    {
                        this.player.setVelocityY(-330);
                    }
                }

                collectStar (player, star)
                {
                    star.disableBody(true, true);

                    //  Add and update the score
                    player.scene.score += 10;
                    player.scene.scoreText.setText('Score: ' + player.scene.score);

                    if (player.scene.stars.countActive(true) === 0)
                    {
                        //  A new batch of stars to collect
                        player.scene.stars.children.iterate(function (child) {

                            child.enableBody(true, child.x, 0, true, true);

                        });

                        var x = (player.x < 400) ? Phaser.Math.Between(400, 800) : Phaser.Math.Between(0, 400);

                        var bomb = this.bombs.create(x, 16, 'bomb');
                        bomb.setBounce(1);
                        bomb.setCollideWorldBounds(true);
                        bomb.setVelocity(Phaser.Math.Between(-200, 200), 20);

                    }
                }

            }

            var config = {
                type: Phaser.WEBGL,
                width: 1200,
                height: 900,
                physics: {
                    default: 'matter',
                    matter: {
                        gravity: { y: 0 },
                        enableSleep: false,
                        debug: false
                    }
                },
                backgroundColor: '#2d2d2d',
                parent: 'phaser-example',
                scene: [ Scene1 , MyScene ]
            };

            function hitBomb (player, bomb)
            {
                this.physics.pause();

                player.setTint(0xff0000);

                player.anims.play('turn');

                player.scene.gameOver = true;
            }

            function updateText (text)
                {
                    text.setText([
                        'Arrow keys to move. Press "Up" to jump.',
                        'You can wall jump!',
                        'Click to toggle rendering Matter debug.'
                        // 'Debug:',
                        // '\tBottom blocked: ' + playerController.blocked.bottom,
                        // '\tLeft blocked: ' + playerController.blocked.left,
                        // '\tRight blocked: ' + playerController.blocked.right
                    ]);
                }

                function smoothMoveCameraTowards (target, cam, smoothFactor)
                {
                    if (smoothFactor === undefined) { smoothFactor = 0; }
                    cam.scrollX = smoothFactor * cam.scrollX + (1 - smoothFactor) * (target.x - cam.width * 0.5);
                    cam.scrollY = smoothFactor * cam.scrollY + (1 - smoothFactor) * (target.y - cam.height * 0.5);
                }

            var game = new Phaser.Game(config);
        </script>
    </body>
</html>