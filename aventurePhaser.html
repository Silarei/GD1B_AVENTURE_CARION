<!doctype html>
<html lang="en">
    <head>
        <meta charset="UTF-8" /><title>Aventure</title>
        <script src="//cdn.jsdelivr.net/npm/phaser@3.55.2/dist/phaser.js"></script>
        <style type="text/css"> body { margin: 0; }</style>
    </head>

    <body>
        <script type="text/javascript">

            //J'en profite pour m'excuser de la lisibilité du code, j'ai voulu utiliser matter plutôt qu'arcade et c'est partit en steack sur beaucoup de chose après coup :S

            class Scene1 extends Phaser.Scene {
                constructor(){
                    super({key : "Scene1" });
                }

                preload () {
                    this.load.spritesheet('ship', 'assets/sprites/pas.png', { frameWidth: 96, frameHeight: 96 });
                    this.load.spritesheet('attack', 'assets/sprites/Attack.png', { frameWidth: 96, frameHeight: 96 });
                    this.load.image('bullet1', 'assets/sprites/bomb.png');
                    this.load.image('ennemy', 'assets/sprites/star.png');
                    this.load.tilemapTiledJSON('map', 'assets/Carte_Nightclub.json');
                    this.load.image('Tileset_Nightclub', 'assets/Tileset_Nightclub.png');
                    this.load.spritesheet('HPBar', 'assets/sprites/HPBar.png', { frameWidth: 254, frameHeight: 254 });
                }

                create () {
                    this.cursors = this.input.keyboard.createCursorKeys();
                    this.speed = Phaser.Math.GetSpeed(300, 1);
                    this.lastFired = 0;
                    this.isDown = false;
                    this.mouseX=0;
                    this.mouseY=0;
                    this.spaceKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.SPACE);
                    this.playerController;
                    this.text;
                    this.cam;
                    this.smoothedControls;
                    this.smoothedControlsV;
                    this.immunityTimer = 100;
                    var cat1 = this.matter.world.nextCategory();
                    var cat2 = this.matter.world.nextCategory();
                    var cat3 = this.matter.world.nextCategory();
                    
                    var Bullet = new Phaser.Class({

                        Extends: Phaser.GameObjects.Image,
                        initialize:

                        function Bullet (scene) {
                            Phaser.GameObjects.Image.call(this, scene, 0, 0, 'bullet1');

                            this.incX = 0;
                            this.incY = 0;
                            this.lifespan = 0;

                            this.speed = Phaser.Math.GetSpeed(600, 1);
                        },

                        fire: function (ship, x, y) {
                            this.setActive(true);
                            this.setVisible(true);
                            this.setPosition(ship.x, ship.y);

                            var angle = Phaser.Math.Angle.Between(x, y, ship.x, ship.y);

                            this.setRotation(angle);

                            this.incX = Math.cos(angle);
                            this.incY = Math.sin(angle);

                            this.lifespan = 150;
                        },

                        update: function (time, delta) {
                            this.lifespan -= delta;

                            this.x -= this.incX * (this.speed * delta);
                            this.y -= this.incY * (this.speed * delta);

                            if (this.lifespan <= 0) {
                                this.setActive(false);
                                this.setVisible(false);
                            }
                        }

                    });

                    var SmoothedHorizontalControl = new Phaser.Class({
                    initialize:

                    function SmoothedHorizontalControl (speed)
                    {
                        this.msSpeed = speed;
                        this.value = 0;
                    },

                    moveLeft: function (delta)
                    {
                        if (this.value > 0) { this.reset(); }
                        this.value -= this.msSpeed * delta;
                        if (this.value < -0.2) { this.value = -0.2; }
                    },

                    moveRight: function (delta)
                    {
                        if (this.value < 0) { this.reset(); }
                        this.value += this.msSpeed * delta;
                        if (this.value > 0.2) { this.value = 0.2; }
                    },

                    reset: function ()
                    {
                        this.value = 0;
                    }
                });

                    var SmoothedVerticalControl = new Phaser.Class({
                    initialize:

                    function SmoothedVerticalControl (speed)
                    {
                        this.msSpeed = speed;
                        this.value = 0;
                    },

                    moveUp: function (delta)
                    {
                        if (this.value < 0) { this.reset(); }
                        this.value += this.msSpeed * delta;
                        if (this.value > 0.2) { this.value = 0.2;}
                    },

                    moveDown: function (delta)
                    {
                        if (this.value > 0) { this.reset(); }
                        this.value -= this.msSpeed * delta;
                        if (this.value < -0.2) { this.value = -0.2; }
                    },

                    reset: function ()
                    {
                        this.value = 0;
                    },
                });

                    this.bullets = this.add.group({
                        classType: Bullet,
                        maxSize: 50,
                        runChildUpdate: true

                    });
                    
                    this.map = this.make.tilemap({ key: 'map' });
                    this.tileset = this.map.addTilesetImage('Tileset_Nightclub');
                    this.groundLayer = this.map.createLayer('Ground', this.tileset, 0, 0);
                    this.layer = this.map.createLayer('Other', this.tileset, 0, 0);
                    this.enemy = this.matter.add.image(830,1000,'ennemy', 0)

                    // Set up the layer to have matter bodies. Any colliding tiles will be given a Matter body.
                    this.map.setCollisionByProperty({ collides: true });
                    this.matter.world.convertTilemapLayer(this.layer);

                    this.matter.world.setBounds(this.map.widthInPixels, this.map.heightInPixels);
                    this.matter.world.createDebugGraphic();
                    this.matter.world.drawDebug = false;

                    this.smoothedControls = new SmoothedHorizontalControl(0.005);
                    this.smoothedControlsV = new SmoothedVerticalControl(0.0005);

                    // The player is a collection of bodies and sensors
                    this.playerController = {
                        matterSprite: this.matter.add.sprite(0, 0, 'ship', 0),
                        attackSprite: this.matter.add.sprite(0, 0, 'attack', 0),
                        blocked: {
                            left: false,
                            right: false,
                            bottom: false,
                            up: false
                        },
                        numTouching: {
                            left: 0,
                            right: 0,
                            bottom: 0,
                            up: 0
                        },
                        sensors: {
                            bottom: null,
                            left: null,
                            right: null,
                            up: null
                        },
                        time: {
                            leftDown: 0,
                            rightDown: 0
                        },
                        lastJumpedAt: 0,
                        speed: {
                            run: 5
                        }
                    };

                    this.M = Phaser.Physics.Matter.Matter;
                    this.w = this.playerController.matterSprite.width;
                    this.h = this.playerController.matterSprite.height;

                    // Move the sensor to player center
                    this.sx = this.w / 2;
                    this.sy = this.h / 2;

                    // The player's body is going to be a compound body.
                    this.playerBody = this.M.Bodies.rectangle(this.sx, this.sy, this.w * 0.75, this.h, { chamfer: { radius: 10 } });
                    this.playerController.sensors.bottom = this.M.Bodies.rectangle(this.sx, this.h, this.sx, 5, { isSensor: true });
                    this.playerController.sensors.left = this.M.Bodies.rectangle(this.sx - this.w * 0.45, this.sy, 5, this.h * 0.25, { isSensor: true });
                    this.playerController.sensors.right = this.M.Bodies.rectangle(this.sx + this.w * 0.45, this.sy, 5, this.h * 0.25, { isSensor: true });
                    this.compoundBody = this.M.Body.create({
                        parts: [
                            this.playerBody, this.playerController.sensors.bottom, this.playerController.sensors.left,
                            this.playerController.sensors.right
                        ],
                        friction: 0.01,
                        maxVelocity: 1,
                        restitution: 0.1 // Prevent body from sticking against a wall
                    });

                    this.playerController.matterSprite
                        .setExistingBody(this.compoundBody)
                        .setPosition(128, 1088);

                    this.playerController.attackSprite
                        .setExistingBody(this.compoundBody)
                        .setPosition(128, 1088);


                    this.cam = this.cameras.main;
                    this.cam.setBounds(0, 0, this.map.widthInPixels, this.map.heightInPixels);
                    smoothMoveCameraTowards(this.playerController.matterSprite, this.cam);

                    this.anims.create({
                        key: 'left',
                        frames: this.anims.generateFrameNumbers('ship', { start: 0, end: 6 }),
                        frameRate: 10,
                        repeat: -1
                    });
                    this.anims.create({
                        key: 'attack',
                        frames: this.anims.generateFrameNumbers('attack', { start: 0, end: 3 }),
                        frameRate: 10,
                        repeat: 0
                    });

                    // Before matter's update, reset the player's count of what surfaces it is touching.
                    this.matter.world.on('beforeupdate', (function (event) {
                        this.playerController.numTouching.left = 0;
                        this.playerController.numTouching.right = 0;
                        this.playerController.numTouching.bottom = 0;
                    }).bind(this));

                    // Loop over the active colliding pairs and count the surfaces the player is touching.
                    this.matter.world.on('collisionactive', (function (event) {
                        this.playerBody = this.playerController.body;
                        this.left = this.playerController.sensors.left;
                        this.right = this.playerController.sensors.right;
                        this.bottom = this.playerController.sensors.bottom;

                        for (this.i = 0; this.i < event.pairs.length; this.i++)
                        {
                            this.bodyA = event.pairs[this.i].bodyA;
                            this.bodyB = event.pairs[this.i].bodyB;

                            if (this.bodyA === this.playerBody || this.bodyB === this.playerBody)
                            {
                                continue;
                            }
                            else if (this.bodyA === this.bottom || this.bodyB === this.bottom)
                            {
                                // Standing on any surface counts (e.g. jumping off of a non-static crate).
                                this.playerController.numTouching.bottom += 1;
                            }
                            else if ((this.bodyA === this.left && this.bodyB.isStatic) || (this.bodyB === this.left && this.bodyA.isStatic))
                            {
                                // Only static objects count since we don't want to be blocked by an object that we
                                // can push around.
                                this.playerController.numTouching.left += 1;
                            }
                            else if ((this.bodyA === this.right && this.bodyB.isStatic) || (this.bodyB === this.right && this.bodyA.isStatic))
                            {
                                this.playerController.numTouching.right += 1;
                            }
                        }
                    }).bind(this));
                    

                    // Update over, so now we can determine if any direction is blocked
                    this.matter.world.on('afterupdate', (function (event) {
                        this.playerController.blocked.right = this.playerController.numTouching.right > 0 ? true : false;
                        this.playerController.blocked.left = this.playerController.numTouching.left > 0 ? true : false;
                        this.playerController.blocked.bottom = this.playerController.numTouching.bottom > 0 ? true : false;
                        this.playerController.blocked.up = this.playerController.numTouching.up > 0 ? true : false;
                    }).bind(this));

                    this.text = this.add.text(512, 512, '', {
                        fontSize: '20px',
                        padding: { x: 20, y: 10 },
                        backgroundColor: '#ffffff',
                        fill: '#000000'
                    });
                    this.text.setScrollFactor(0);
                    updateText(this.text);

                    this.HPBar = this.add.sprite(128, 128, 'HPBar', 0);
                    this.HPBar.setScrollFactor(0);



                    this.input.on('pointerdown', pointer =>  {

                        this.isDown = true;
                        this.mouseX = pointer.worldX;
                        this.mouseY = pointer.worldY;
                        this.playerController.attackSprite.anims.play('attack', true);

                    });

                    this.input.on('pointermove', pointer =>  {

                        this.mouseX = pointer.worldX;
                        this.mouseY = pointer.worldY;

                    });

                    this.input.on('pointerup', pointer =>  {

                        this.isDown = false;

                    });
                    this.playerController.matterSprite.setCollisionCategory(cat2);
                    this.enemy.setCollisionCategory(cat2);

                    this.matter.world.on('collisionstart', (function (event) {
                        console.log('prout');
                        if (invincible == false){
                            invincible = true;
                            health -= 1;
                            this.playerController.matterSprite.setTint(0xff0000);
                        }
                    }).bind(this));
                }

                update (time, delta) {

                    if (this.isDown && time > this.lastFired) {
                        this.bullet = this.bullets.get();

                        if (this.bullet) {                            
                            this.bullet.fire(this.playerController.matterSprite, this.mouseX, this.mouseY);
                            

                            this.lastFired = time + 500;
                        }
                    }

                    this.matterSprite = this.playerController.matterSprite;
                    this.attackSprite = this.playerController.attackSprite;

                    this.matterSprite.setRotation(Phaser.Math.Angle.Between(this.mouseX, this.mouseY, this.matterSprite.x, this.matterSprite.y) - Math.PI / 2);
                    this.attackSprite.setRotation(Phaser.Math.Angle.Between(this.mouseX, this.mouseY, this.attackSprite.x, this.attackSprite.y) - Math.PI / 2);


                    if (this.matterSprite.x > 2200) {
                        this.scene.start('MyScene');
                    }


                    // Movement

                    this.oldVelocityX;
                    this.targetVelocityX;
                    this.newVelocityX;
                    this.oldVelocityY;
                    this.targetVelocityY;
                    this.newVelocityY;

                    if (this.cursors.left.isDown && !this.playerController.blocked.left)
                    {
                        this.smoothedControls.moveLeft(delta);
                        this.matterSprite.anims.play('left', true);

                        // Lerp the velocity towards the max run using the smoothed controls. This simulates a
                        // player controlled acceleration.
                        this.oldVelocityX = this.matterSprite.body.velocity.x;
                        this.targetVelocityX = -this.playerController.speed.run;
                        this.newVelocityX = Phaser.Math.Linear(this.oldVelocityX, this.targetVelocityX, -this.smoothedControls.value);

                        this.matterSprite.setVelocityX(this.newVelocityX);
                    }
                    else if (this.cursors.right.isDown && !this.playerController.blocked.right)
                    {
                        this.smoothedControls.moveRight(delta);
                        this.matterSprite.anims.play('left', true);

                        // Lerp the velocity towards the max run using the smoothed controls. This simulates a
                        // player controlled acceleration.
                        this.oldVelocityX = this.matterSprite.body.velocity.x;
                        this.targetVelocityX = this.playerController.speed.run;
                        this.newVelocityX = Phaser.Math.Linear(this.oldVelocityX, this.targetVelocityX, this.smoothedControls.value);

                        this.matterSprite.setVelocityX(this.newVelocityX);
                    }
                    else
                    {
                        this.smoothedControls.reset();
                    }

                    if (this.cursors.down.isDown && !this.playerController.blocked.bottom)
                    {
                        this.smoothedControlsV.moveUp(delta);
                        this.matterSprite.anims.play('left', true);
                        // Lerp the velocity towards the max run using the smoothed controls. This simulates a
                        // player controlled acceleration.
                        this.oldVelocityY = this.matterSprite.body.velocity.y;
                        this.targetVelocityY = this.playerController.speed.run;
                        this.newVelocityY = Phaser.Math.Linear(this.oldVelocityY, this.targetVelocityY, this.smoothedControlsV.value);

                        this.matterSprite.setVelocityY(this.newVelocityY);
                    }
                    else if (this.cursors.up.isDown && !this.playerController.blocked.up)
                    {
                        this.smoothedControlsV.moveDown(delta);
                        this.matterSprite.anims.play('left', true);
                        // Lerp the velocity towards the max run using the smoothed controls. This simulates a
                        // player controlled acceleration.
                        this.oldVelocityY = this.matterSprite.body.velocity.y;
                        this.targetVelocityY = -this.playerController.speed.run;
                        this.newVelocityY = Phaser.Math.Linear(this.oldVelocityY, this.targetVelocityY, -this.smoothedControlsV.value);

                        this.matterSprite.setVelocityY(this.newVelocityY);
                    }
                    else
                    {
                        this.smoothedControlsV.reset();
                    }

                    if (!this.cursors.up.isDown && !this.cursors.down.isDown && !this.cursors.left.isDown && !this.cursors.right.isDown) {
                        this.matterSprite.anims.play('left', false);
                    }

                    if (this.spaceKey.isDown) {
                        if (this.text.alpha == 1) {
                            this.text.setAlpha(0);
                        }
                        else {
                            this.text.setAlpha(1);
                        }
                    }

                    if(invincible){
                        this.immunityTimer -=1 ;
                        if(this.immunityTimer == 0){
                            this.immunityTimer = 100;
                            this.playerController.matterSprite.setTint(0xffffff);
                            invincible = false ;
                        }
                    }

                    smoothMoveCameraTowards(this.matterSprite, this.cam, 0.9);
                    updateText(this.text);
                    if (this.enemy.x == this.matterSprite.x) {
                        this.enemy.setVelocityX(0)
                    }
                    else if (this.enemy.x < this.matterSprite.x) {
                        this.enemy.setVelocityX(1)
                    }
                    else if (this.enemy.x > this.matterSprite.x) {
                        this.enemy.setVelocityX(-1)
                    }
                    if (this.enemy.y == this.matterSprite.y) {
                        this.enemy.setVelocityY(0)
                    }
                    if (this.enemy.y < this.matterSprite.y) {
                        this.enemy.setVelocityY(1)
                    }
                    if (this.enemy.y > this.matterSprite.y && this.enemy.y != this.matterSprite.y) {
                        this.enemy.setVelocityY(-1)
                    }
                }
            }









































            class MyScene extends Phaser.Scene {
                constructor(){
                    super({key : "MyScene" });
                }

                preload () {
                    this.load.spritesheet('ship', 'assets/sprites/pas.png', { frameWidth: 96, frameHeight: 96 });
                    this.load.spritesheet('attack', 'assets/sprites/Attack.png', { frameWidth: 96, frameHeight: 96 });
                    this.load.image('bullet1', 'assets/sprites/bomb.png');
                    this.load.image('ennemy', 'assets/sprites/star.png');
                    this.load.tilemapTiledJSON('map', 'assets/Carte_Nightclub.json');
                    this.load.image('Tileset_Nightclub', 'assets/Tileset_Nightclub.png');
                    this.load.spritesheet('HPBar', 'assets/sprites/HPBar.png', { frameWidth: 254, frameHeight: 254 });
                }

                create () {
                    this.cursors = this.input.keyboard.createCursorKeys();
                    this.speed = Phaser.Math.GetSpeed(300, 1);
                    this.lastFired = 0;
                    this.isDown = false;
                    this.mouseX=0;
                    this.mouseY=0;
                    this.spaceKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.SPACE);
                    this.playerController;
                    this.text;
                    this.cam;
                    this.smoothedControls;
                    this.smoothedControlsV;
                    this.immunityTimer = 100;
                    var cat1 = this.matter.world.nextCategory();
                    var cat2 = this.matter.world.nextCategory();
                    var cat3 = this.matter.world.nextCategory();
                    
                    var Bullet = new Phaser.Class({

                        Extends: Phaser.GameObjects.Image,
                        initialize:

                        function Bullet (scene) {
                            Phaser.GameObjects.Image.call(this, scene, 0, 0, 'bullet1');

                            this.incX = 0;
                            this.incY = 0;
                            this.lifespan = 0;

                            this.speed = Phaser.Math.GetSpeed(600, 1);
                        },

                        fire: function (ship, x, y) {
                            this.setActive(true);
                            this.setVisible(true);
                            this.setPosition(ship.x, ship.y);

                            var angle = Phaser.Math.Angle.Between(x, y, ship.x, ship.y);

                            this.setRotation(angle);

                            this.incX = Math.cos(angle);
                            this.incY = Math.sin(angle);

                            this.lifespan = 150;
                        },

                        update: function (time, delta) {
                            this.lifespan -= delta;

                            this.x -= this.incX * (this.speed * delta);
                            this.y -= this.incY * (this.speed * delta);

                            if (this.lifespan <= 0) {
                                this.setActive(false);
                                this.setVisible(false);
                            }
                        }

                    });

                    var SmoothedHorizontalControl = new Phaser.Class({
                    initialize:

                    function SmoothedHorizontalControl (speed)
                    {
                        this.msSpeed = speed;
                        this.value = 0;
                    },

                    moveLeft: function (delta)
                    {
                        if (this.value > 0) { this.reset(); }
                        this.value -= this.msSpeed * delta;
                        if (this.value < -0.2) { this.value = -0.2; }
                    },

                    moveRight: function (delta)
                    {
                        if (this.value < 0) { this.reset(); }
                        this.value += this.msSpeed * delta;
                        if (this.value > 0.2) { this.value = 0.2; }
                    },

                    reset: function ()
                    {
                        this.value = 0;
                    }
                });

                    var SmoothedVerticalControl = new Phaser.Class({
                    initialize:

                    function SmoothedVerticalControl (speed)
                    {
                        this.msSpeed = speed;
                        this.value = 0;
                    },

                    moveUp: function (delta)
                    {
                        if (this.value < 0) { this.reset(); }
                        this.value += this.msSpeed * delta;
                        if (this.value > 0.2) { this.value = 0.2;}
                    },

                    moveDown: function (delta)
                    {
                        if (this.value > 0) { this.reset(); }
                        this.value -= this.msSpeed * delta;
                        if (this.value < -0.2) { this.value = -0.2; }
                    },

                    reset: function ()
                    {
                        this.value = 0;
                    },
                });

                    this.bullets = this.add.group({
                        classType: Bullet,
                        maxSize: 50,
                        runChildUpdate: true

                    });
                    
                    this.map = this.make.tilemap({ key: 'map' });
                    this.tileset = this.map.addTilesetImage('Tileset_Nightclub');
                    this.groundLayer = this.map.createLayer('Ground', this.tileset, 0, 0);
                    this.layer = this.map.createLayer('Other', this.tileset, 0, 0);
                    this.enemy = this.matter.add.image(830,1000,'ennemy', 0)

                    // Set up the layer to have matter bodies. Any colliding tiles will be given a Matter body.
                    this.map.setCollisionByProperty({ collides: true });
                    this.matter.world.convertTilemapLayer(this.layer);

                    this.matter.world.setBounds(this.map.widthInPixels, this.map.heightInPixels);
                    this.matter.world.createDebugGraphic();
                    this.matter.world.drawDebug = false;

                    this.smoothedControls = new SmoothedHorizontalControl(0.005);
                    this.smoothedControlsV = new SmoothedVerticalControl(0.0005);

                    // The player is a collection of bodies and sensors
                    this.playerController = {
                        matterSprite: this.matter.add.sprite(0, 0, 'ship', 0),
                        attackSprite: this.matter.add.sprite(0, 0, 'attack', 0),
                        blocked: {
                            left: false,
                            right: false,
                            bottom: false,
                            up: false
                        },
                        numTouching: {
                            left: 0,
                            right: 0,
                            bottom: 0,
                            up: 0
                        },
                        sensors: {
                            bottom: null,
                            left: null,
                            right: null,
                            up: null
                        },
                        time: {
                            leftDown: 0,
                            rightDown: 0
                        },
                        lastJumpedAt: 0,
                        speed: {
                            run: 5
                        }
                    };

                    this.M = Phaser.Physics.Matter.Matter;
                    this.w = this.playerController.matterSprite.width;
                    this.h = this.playerController.matterSprite.height;

                    // Move the sensor to player center
                    this.sx = this.w / 2;
                    this.sy = this.h / 2;

                    // The player's body is going to be a compound body.
                    this.playerBody = this.M.Bodies.rectangle(this.sx, this.sy, this.w * 0.75, this.h, { chamfer: { radius: 10 } });
                    this.playerController.sensors.bottom = this.M.Bodies.rectangle(this.sx, this.h, this.sx, 5, { isSensor: true });
                    this.playerController.sensors.left = this.M.Bodies.rectangle(this.sx - this.w * 0.45, this.sy, 5, this.h * 0.25, { isSensor: true });
                    this.playerController.sensors.right = this.M.Bodies.rectangle(this.sx + this.w * 0.45, this.sy, 5, this.h * 0.25, { isSensor: true });
                    this.compoundBody = this.M.Body.create({
                        parts: [
                            this.playerBody, this.playerController.sensors.bottom, this.playerController.sensors.left,
                            this.playerController.sensors.right
                        ],
                        friction: 0.01,
                        maxVelocity: 1,
                        restitution: 0.1 // Prevent body from sticking against a wall
                    });

                    this.playerController.matterSprite
                        .setExistingBody(this.compoundBody)
                        .setPosition(128, 1088);

                    this.playerController.attackSprite
                        .setExistingBody(this.compoundBody)
                        .setPosition(128, 1088);


                    this.cam = this.cameras.main;
                    this.cam.setBounds(0, 0, this.map.widthInPixels, this.map.heightInPixels);
                    smoothMoveCameraTowards(this.playerController.matterSprite, this.cam);

                    this.anims.create({
                        key: 'left',
                        frames: this.anims.generateFrameNumbers('ship', { start: 0, end: 6 }),
                        frameRate: 10,
                        repeat: -1
                    });
                    this.anims.create({
                        key: 'attack',
                        frames: this.anims.generateFrameNumbers('attack', { start: 0, end: 3 }),
                        frameRate: 10,
                        repeat: 0
                    });

                    // Before matter's update, reset the player's count of what surfaces it is touching.
                    this.matter.world.on('beforeupdate', (function (event) {
                        this.playerController.numTouching.left = 0;
                        this.playerController.numTouching.right = 0;
                        this.playerController.numTouching.bottom = 0;
                    }).bind(this));

                    // Loop over the active colliding pairs and count the surfaces the player is touching.
                    this.matter.world.on('collisionactive', (function (event) {
                        this.playerBody = this.playerController.body;
                        this.left = this.playerController.sensors.left;
                        this.right = this.playerController.sensors.right;
                        this.bottom = this.playerController.sensors.bottom;

                        for (this.i = 0; this.i < event.pairs.length; this.i++)
                        {
                            this.bodyA = event.pairs[this.i].bodyA;
                            this.bodyB = event.pairs[this.i].bodyB;

                            if (this.bodyA === this.playerBody || this.bodyB === this.playerBody)
                            {
                                continue;
                            }
                            else if (this.bodyA === this.bottom || this.bodyB === this.bottom)
                            {
                                // Standing on any surface counts (e.g. jumping off of a non-static crate).
                                this.playerController.numTouching.bottom += 1;
                            }
                            else if ((this.bodyA === this.left && this.bodyB.isStatic) || (this.bodyB === this.left && this.bodyA.isStatic))
                            {
                                // Only static objects count since we don't want to be blocked by an object that we
                                // can push around.
                                this.playerController.numTouching.left += 1;
                            }
                            else if ((this.bodyA === this.right && this.bodyB.isStatic) || (this.bodyB === this.right && this.bodyA.isStatic))
                            {
                                this.playerController.numTouching.right += 1;
                            }
                        }
                    }).bind(this));
                    

                    // Update over, so now we can determine if any direction is blocked
                    this.matter.world.on('afterupdate', (function (event) {
                        this.playerController.blocked.right = this.playerController.numTouching.right > 0 ? true : false;
                        this.playerController.blocked.left = this.playerController.numTouching.left > 0 ? true : false;
                        this.playerController.blocked.bottom = this.playerController.numTouching.bottom > 0 ? true : false;
                        this.playerController.blocked.up = this.playerController.numTouching.up > 0 ? true : false;
                    }).bind(this));

                    this.text = this.add.text(512, 512, '', {
                        fontSize: '20px',
                        padding: { x: 20, y: 10 },
                        backgroundColor: '#ffffff',
                        fill: '#000000'
                    });
                    this.text.setScrollFactor(0);
                    updateText(this.text);

                    this.HPBar = this.add.sprite(128, 128, 'HPBar', 0);
                    this.HPBar.setScrollFactor(0);



                    this.input.on('pointerdown', pointer =>  {

                        this.isDown = true;
                        this.mouseX = pointer.worldX;
                        this.mouseY = pointer.worldY;
                        this.playerController.attackSprite.anims.play('attack', true);

                    });

                    this.input.on('pointermove', pointer =>  {

                        this.mouseX = pointer.worldX;
                        this.mouseY = pointer.worldY;

                    });

                    this.input.on('pointerup', pointer =>  {

                        this.isDown = false;

                    });
                    this.playerController.matterSprite.setCollisionCategory(cat2);
                    this.enemy.setCollisionCategory(cat2);

                    this.matter.world.on('collisionstart', (function (event) {
                        console.log('prout');
                        if (invincible == false){
                            invincible = true;
                            health -= 1;
                            this.playerController.matterSprite.setTint(0xff0000);
                        }
                    }).bind(this));
                }

                update (time, delta) {

                    if (this.isDown && time > this.lastFired) {
                        this.bullet = this.bullets.get();

                        if (this.bullet) {                            
                            this.bullet.fire(this.playerController.matterSprite, this.mouseX, this.mouseY);
                            

                            this.lastFired = time + 500;
                        }
                    }

                    this.matterSprite = this.playerController.matterSprite;
                    this.attackSprite = this.playerController.attackSprite;

                    this.matterSprite.setRotation(Phaser.Math.Angle.Between(this.mouseX, this.mouseY, this.matterSprite.x, this.matterSprite.y) - Math.PI / 2);
                    this.attackSprite.setRotation(Phaser.Math.Angle.Between(this.mouseX, this.mouseY, this.attackSprite.x, this.attackSprite.y) - Math.PI / 2);

                    // Movement

                    this.oldVelocityX;
                    this.targetVelocityX;
                    this.newVelocityX;
                    this.oldVelocityY;
                    this.targetVelocityY;
                    this.newVelocityY;

                    if (this.cursors.left.isDown && !this.playerController.blocked.left)
                    {
                        this.smoothedControls.moveLeft(delta);
                        this.matterSprite.anims.play('left', true);

                        // Lerp the velocity towards the max run using the smoothed controls. This simulates a
                        // player controlled acceleration.
                        this.oldVelocityX = this.matterSprite.body.velocity.x;
                        this.targetVelocityX = -this.playerController.speed.run;
                        this.newVelocityX = Phaser.Math.Linear(this.oldVelocityX, this.targetVelocityX, -this.smoothedControls.value);

                        this.matterSprite.setVelocityX(this.newVelocityX);
                    }
                    else if (this.cursors.right.isDown && !this.playerController.blocked.right)
                    {
                        this.smoothedControls.moveRight(delta);
                        this.matterSprite.anims.play('left', true);

                        // Lerp the velocity towards the max run using the smoothed controls. This simulates a
                        // player controlled acceleration.
                        this.oldVelocityX = this.matterSprite.body.velocity.x;
                        this.targetVelocityX = this.playerController.speed.run;
                        this.newVelocityX = Phaser.Math.Linear(this.oldVelocityX, this.targetVelocityX, this.smoothedControls.value);

                        this.matterSprite.setVelocityX(this.newVelocityX);
                    }
                    else
                    {
                        this.smoothedControls.reset();
                    }

                    if (this.cursors.down.isDown && !this.playerController.blocked.bottom)
                    {
                        this.smoothedControlsV.moveUp(delta);
                        this.matterSprite.anims.play('left', true);
                        // Lerp the velocity towards the max run using the smoothed controls. This simulates a
                        // player controlled acceleration.
                        this.oldVelocityY = this.matterSprite.body.velocity.y;
                        this.targetVelocityY = this.playerController.speed.run;
                        this.newVelocityY = Phaser.Math.Linear(this.oldVelocityY, this.targetVelocityY, this.smoothedControlsV.value);

                        this.matterSprite.setVelocityY(this.newVelocityY);
                    }
                    else if (this.cursors.up.isDown && !this.playerController.blocked.up)
                    {
                        this.smoothedControlsV.moveDown(delta);
                        this.matterSprite.anims.play('left', true);
                        // Lerp the velocity towards the max run using the smoothed controls. This simulates a
                        // player controlled acceleration.
                        this.oldVelocityY = this.matterSprite.body.velocity.y;
                        this.targetVelocityY = -this.playerController.speed.run;
                        this.newVelocityY = Phaser.Math.Linear(this.oldVelocityY, this.targetVelocityY, -this.smoothedControlsV.value);

                        this.matterSprite.setVelocityY(this.newVelocityY);
                    }
                    else
                    {
                        this.smoothedControlsV.reset();
                    }

                    if (!this.cursors.up.isDown && !this.cursors.down.isDown && !this.cursors.left.isDown && !this.cursors.right.isDown) {
                        this.matterSprite.anims.play('left', false);
                    }

                    if (this.spaceKey.isDown) {
                        if (this.text.alpha == 1) {
                            this.text.setAlpha(0);
                        }
                        else {
                            this.text.setAlpha(1);
                        }
                    }

                    if(invincible){
                        this.immunityTimer -=1 ;
                        if(this.immunityTimer == 0){
                            this.immunityTimer = 100;
                            this.playerController.matterSprite.setTint(0xffffff);
                            invincible = false ;
                        }
                    }

                    smoothMoveCameraTowards(this.matterSprite, this.cam, 0.9);
                    updateText(this.text);
                    if (this.enemy.x == this.matterSprite.x) {
                        this.enemy.setVelocityX(0)
                    }
                    else if (this.enemy.x < this.matterSprite.x) {
                        this.enemy.setVelocityX(1)
                    }
                    else if (this.enemy.x > this.matterSprite.x) {
                        this.enemy.setVelocityX(-1)
                    }
                    if (this.enemy.y == this.matterSprite.y) {
                        this.enemy.setVelocityY(0)
                    }
                    if (this.enemy.y < this.matterSprite.y) {
                        this.enemy.setVelocityY(1)
                    }
                    if (this.enemy.y > this.matterSprite.y && this.enemy.y != this.matterSprite.y) {
                        this.enemy.setVelocityY(-1)
                    }
                }
            }


            var config = {
                type: Phaser.WEBGL,
                width: screen.width,
                height: screen.height,
                physics: {
                    default: 'matter',
                    matter: {
                        gravity: { y: 0 },
                        enableSleep: false,
                        debug: true
                    }
                },
                backgroundColor: '#2d2d2d',
                parent: 'phaser-example',
                scene: [ Scene1 , MyScene ]
            };

            function updateText (text)
                {
                    text.setText([
                        'Arrow keys to move.',
                        'Click to attack.',
                        'Space to make this dissapear.'
                        // 'Debug:',
                        // '\tBottom blocked: ' + playerController.blocked.bottom,
                        // '\tLeft blocked: ' + playerController.blocked.left,
                        // '\tRight blocked: ' + playerController.blocked.right
                    ]);
                }

            function smoothMoveCameraTowards (target, cam, smoothFactor)
                {
                    if (smoothFactor === undefined) { smoothFactor = 0; }
                    cam.scrollX = smoothFactor * cam.scrollX + (1 - smoothFactor) * (target.x - cam.width * 0.5);
                    cam.scrollY = smoothFactor * cam.scrollY + (1 - smoothFactor) * (target.y - cam.height * 0.5);
                }

            
            

            var invincible = false;
            var health = 4;
            var game = new Phaser.Game(config);
        </script>
    </body>
</html>